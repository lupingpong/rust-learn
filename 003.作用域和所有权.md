## heap和stack

程序载入内存后，需要为变量分配内存空间，内存空间的逻辑结构上可以划分为栈（stack）和堆（head），栈和堆不是某一门编程语言定义的，是由计算机体系结构决定的。

    栈（stack）: 函数调用中的本地变量（函数参数、局部变量等）存放的区域，先进后出，与数据结构中的栈类似。

    堆（heap）：动态分配内存的区域，分配内存之后，需要“手动”进行内存释放，与数据结构中的堆不是一回事。

    从生命周期上来说，栈适合放小且存活短的数据，堆则相反，当然这不是一定的，堆上分配的消耗相对而言要大一些；堆是共享区域，栈则是当前上下文环境持有（每个线程有自己的栈区）。

    此外，堆上分配不要求内存连续，但是栈则要求连续。

## 作用域

> fn main(){}

>fn show(){ {}  }

以“{”开始，和“}”结束的区间是一个作用域，一个变量在{}中产生，脱离该区域之后就无效了，也即超过了该变量允许作用的区域。

>fn main() {
>>    let y = "Rust";
>>>    {
>>>>        println!("{}",y); //Rust
>>>>        let y= 1;
>>>>        println!("{}",y); //1
>>>   }
>>
>>    println!("{}",y);  //Rust
>
>}

如果存在嵌套，规则依旧，外层作用域定义的变量，在内层作用域内是有效的，反之则无效。

## Ownership

对于分配在堆上的内存，需要“手动”回收，常见的手动方式有两种：GC回收器和显示使用内存管理（释放和开辟内存的函数）。

Rust没有使用常见的处理机制，使用了新的术语“所有权”（Ownership）规则进行描述：

    1. 每一个值（value）都有一个owner，这个owner就是持有该值的那个变量（variable）。

    2. 同一时刻一个值有且只能有一个owner。

    3. 当owner超出所在作用域时，这个值将会被回收删除（dropped）。

## 浅拷贝和深拷贝


    浅拷贝：复制之后，仅仅复制部分数据（这部分数据往往是与源数据指向数据关联的，这类数据大部分情况下存在stack上，比如指针），相互之间存在影响。

    深拷贝：复制之后，跟源数据完全是独立的两份数据，相互之间不会有任何影响。

    从另外一个角度上看，浅拷贝只复制了一层，深拷贝则是递归复制了所有。


## Ownership与变量

> let x:i32 = 100;

> 语义：将100绑定到变量x上。

> 变量是有名字的值，在这里，“=”左边的x本身分配在stack上，“=”右边的值的100也是分配在栈上的，但“=”右边的值可以分配在stack也可以在heap，或者混合。


给一个值（数据）分配内存空间，大部分情况下，要么分配在stack上，要么在heap上，一个值被绑定到一个变量上后，再次将该值（使用接收绑定的变量）绑定到另外一个变量发生交互行为。

场景：赋值、函数调用传递参数、函数调用返回等。

交互类型有三种：Move、Clone、Copy，讨论交互类型要基于数据是在stack还是heap分配或者混合，数据分配的不同，语义也不一样。

此外，这些交互类型是由编译器决定的，不存在显示操作的语法。

1. Move

     语义上等价于浅拷贝，但是会将所有权转给第二个被绑定的变量，按照所有权的规则，同一时刻有且只能有一个owner，因此第一个变量由于不在是owner，从而无效（不可用）。

2. Clone
    
    语义上等价于深拷贝，拷贝之后是两份独立的数据，不论是stack还是head上的数据，都是两份独立的数据，不存在owner转移和失效的情况。

3. Copy
   
   对于栈上的数据大小在编译的时候是确定的，或者说实现了Copy trait的数据类型（必须是在栈上分配的），当发生交互时，也不存在owner转移和失效的情况。

   常见的基础类型、由基础类型组合成的复合类型元组等都实现了Copy。
    
## Ownership与Fn函数
 
 fn函数所有权语义跟变量绑定语义类似，也会发生Move或Copy；操作函数会有两种行为，其一是将变量作为参数传递给函数，其二是返回结果。

 >let x = 100;
 >
 >fn_copy(x);
 >
 >println!("{}",x); //100
    
    将变量x传递给函数fn_copy,发生了Copy，x依旧是100的owner。

>fn fn_return() -> i32 {
>>let a = 100;
>>
>>a
>>
>}
>
>let y  = fn_return();
>
    函数fn_return返回变量a,发生Copy,所有权转给了y
