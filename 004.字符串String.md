## 字符串（String）

在编译期能确定大小的数据（比如:Integer、float、char、bool),在栈（stack）上进行内存空间分配，另外一类不确定的或者说动态数据在堆（heap）分配，比如：字符串。

字符串是所有语言在编程过程中使用得最多的数据类型，Rust提供了两种字符串：String和&str。

>let s:String = String::from("hello");

变量s存储在栈上，包含三个信息：一个指针、数据的容量、数据的长度；其中，指针所指向的是分配在堆上的缓冲区，也即真正数据的存储之地。

所以，String对象本身是固定三个字（word）大小，但是指针指向的缓冲区存内容是可变的，在编译期是不确定的。

## 引用（Refrence）和借用（Borrowing）

当变量与数据发生Move类型的交互时，会转移所属权（ownership）。

对于基本数据类型（Integer、float、char、bool）等实现了Copy，因此不会发生Move行为，但是字符串类型会发生。

>let s:String = String::from("hello");

>let s1 = s2;

>println!("{}",s); //error,发生了move，所有权转移了，s无效

同样的，当进行函数参数传递的时候或者返回值，也会发生Move。

Rsut提供了引用语法，可以创建一个引用指向会发生Move的数据，但是不转移所有权，引用本身没有ownership。

>let s1 = &s;

>println!("{}",s);  //hello

>let s3 = &&&&&&&&s;

>println!("{}",s3);  //hello


引用（Refrence）：操作符“&”，创建引用指向的行为称之为借用（Borrowing）。

解引用(Dereference )：操作符“*”，引用的逆反过程,部分情况下会自动解引用(隐式调用deref)。

>s3.push_str("rust"); //error,不可变特性

变量的不可变性同样适用于引用，默认情况下，都是不可变的，也即不能对引用进行有可能发生变化的操作。

如果需要可变特性，适用关键字mut，格式：&mut，前提是被引用指向的变量也是mut修饰。

安全规则：


    1. 同一作用域内被mut修饰的变量只允许最多一次可变引用，除非其中一个引用在另外一个引用使用时能明确知晓不会在使用。

    2. 同一作用域内可变引用和不可变引用不能同时存在，除非其中一个引用在另外一个引用使用时能明确知晓不会在使用。

    3. 被引用的变量存活周期不能比引用短。

## 切片（Slice）

切片（Slice）是一种引用，可以用于获取连续集合(比如：字符串、数组等)的一部分元素。

格式：&variable[x1..x2]，x1为起始位置（包含,类似索引下标，从0开始），x2为结束为位置（不包含,可以使用等号=x进行包含），均可以省略。

>let s = String::from("hello");

>println!("{}",&s[1..=3]); //ell

    注意：由于Rust的字符串使用的是UTF-8的编码，UTF-8是可变长度(1~4个字节)的编码格式，所以切片长度的时候要注意大小。

## &str

字符串String是在堆上进行分配的，Rust还提供了一种字符串&str。

>let s:&str = "hello rust";

字符串字面量：被双引号包含的文本,引用自预分配文本(preallocated text)切片，预分配文本存储在可执程序的内存中，不依赖于堆上分配，而对于变量s是在栈上分配的，包含两个信息：一个是指向刚刚的内存，一个是文本字符串大小。

&str 和 String之间可以相互转换。

>let s1:String = s.to_string();

>let s2:&str = &s1[..];
