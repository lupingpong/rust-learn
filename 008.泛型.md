## 基本数据类型转换

Rust提供的几种基本数据类型之间，是不会进行隐式的数据类型转换的，只能显示使用关键字 as进行转换。

形式： xx as yy

> let a:f64 = 100i32;  //error  编译错误

> let a:f64 = 100i32 as f64 //ok

不是所有数据类型之间都能进行转换的，bool类型就不能转为浮点类型，bool转为整数类型时true为1 false为0，但是所有数字类型均不能转为bool。

此外，当发生溢出行为时，Rust并不会报错。


## 统一类型

不要重复自己的格言，永不过时！

在定义方法、函数、结构体、枚举等时，通常来说，需要考虑通用性，最基础的通用性便是对不同数据类型的‘统一’。

Rust中所有的变量都是需要声明数据类型的，也即说明不同数据类型之间不进行强制转换是不能相互兼容的，但不同数据类型之间有些是不能进行强制转换的。

因此定义一种看上去‘统一’、能兼容所有数据类型的数据类型时不可能的。

## 泛型

泛型的存在便是从另外一个角度去处理这个‘统一’的问题，将数据类型本身当成参数进行传递，也即参数化类型。

当需要用到泛型时，必须先声明泛型，使用\<T>即可，其中<>是固定语法，T则是泛型的符号，可以是任何符号,不一定要是T，只不过习惯如此。

当多个泛型时，可以是<T,U,W>。

1. 函数

    > fn getbig\<T>(list:&\<T>) -> T {xxxxxxx}

2. 结构体
   
   > struct User\<T> {xxx:T}

3. 方法
  
    > impl\<T> User\<T> {
    >>    fn get(&self)->&T{
    >>        &self.xxx
    >>    }
    >}

4. 枚举

    > enum Color\<T> {
    >>  ERROR(T),

    >>   OK
    >
    >}

在使用含有泛型的函数、方法、结构体时，给定数据类型即可，且对于一次T只能有一个数据类型，也即不能产生歧义。


> struct P\<T> {x:T,y:T}
>
>let p = P{x:100i32,y:200.0f64} //error 这里T是i32类型，不能再是f64
>
> struct P<T,U>  {x:T,y:U}
>
>let p = P{x:100i32,y:200.0f64} //ok

类型标识符号T，只是个占位符，可以是任何满足Rust语法的符号，这一点在方法上很明显。

>struct User\<T> {xxx:T}
>
>impl\<W> User<W> { xxxxxx }  //即便User中的泛型符号是T，此处也可以是W，只不过习惯统一为T。
