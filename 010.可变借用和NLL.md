## 所有权语义

规则：一个值只能有一个所有者！

已知：函数调用、方法调用、赋值等均会导致所有权转移，也即发生了Move，所有权转移之后，之前的变量不可用了。

需求1：Move之后，之前的变量依旧可用（所有权不转移）

需求2：Move之后，不转移所有权

解答需求1：

   前提条件数据类型实现了Copy，实现Copy trait，则再Move行为后，只是进行一次浅拷贝，之前的变量依旧可以用。
   
解答需求2：   
 
   不是所有类型都实现了Copy的，基本数据类型都实现了，但是对于需要在堆上进行数据分配的类型，不能实现Copy。
   
   因此Rust使用了借用（引用）的概念，使用借用，可以不发生转移。
   
   不可变借用，实现了Copy trait。
   
   可变借用，没有实现Copy trait，如果实现了的话会存在数据共享竞争问题，所以会转移所有权。

## 再借用和NLL

可变借用，可以再次借用（reborrow），再次借用会产生可变借用不转移所有权的假象，实在是因为NLL（non lexical lifetime）的原因。

## 手段与目的

所有权是为了保证内存安全这个目的手段。

所有权是抽象的，为了具体实现，通过Move进行所有权转移，引入借用来满足程序本身的一致性，通过Copy trait来实现数据共享。


